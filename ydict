#!/usr/bin/env python
# coding=UTF-8
# Chen Wen <chenpc@cs.nctu.edu.tw>
# Web Site http://code.google.com/p/ydict/
# Blog : http://chenpc.csie.in

import getopt
import sys
import string
import httplib, urllib,string,sys
from HTMLParser import HTMLParser
from optparse import OptionParser
import locale
from codecs import EncodedFile
import shelve,os
import random
import ConfigParser
from multiprocessing import Process, JoinableQueue, Queue, Pool
#Google API
try:
	import gdata.spreadsheet.service
	import gdata.service
	import gdata.spreadsheet
except ImportError:
	pass

version="ydict 1.1.0"
red="\33[31;1m"
lindigo="\33[36;1m"
indigo="\33[36m"
green="\33[32m"
yellow="\33[33;1m"
blue="\33[34;1m"
org="\33[0m"
light="\33[0;1m"
learn=0
database=0
voicedata = ""
playback = ""

class godb():
	def __init__(self, email, password, spreadsheet, worksheet):
		self.gd_client = gdata.spreadsheet.service.SpreadsheetsService()
		self.gd_client.email = email
		self.gd_client.password = password
		self.gd_client.source = 'Spreadsheets GData Sample'
		self.gd_client.ProgrammaticLogin()
		self.curr_key = ''
		self.curr_wksht_id = ''
		self.list_feed = None
		self.word = dict()
		self.wordlist = list()
		self.curr_key = self.SearchForSpreadsheet(spreadsheet)
		self.curr_wksht_id = self.SearchForWorksheet(self.curr_key, worksheet)	
		self.CellGetAction(self.curr_key, self.curr_wksht_id)
		self.saving = False
		self.q = JoinableQueue()
		self.p = Process(target=self.wb, args=(self.q, self.saving))
		self.p.daemon = True
		self.p.start()
		
	def wb(self, q, saving):
		while(1) :
			(k, v, index)=q.get()
			entry = self.gd_client.UpdateCell( row=str(index), col=1,
			inputValue=str(k),
			key=self.curr_key, wksht_id=self.curr_wksht_id)

			entry = self.gd_client.UpdateCell( row=str(index), col=2,
			inputValue=str(v),
			key=self.curr_key, wksht_id=self.curr_wksht_id)
			q.task_done()


	def __getitem__(self, key):
		return self.wordlist[self.word[key]-1]

	def __setitem__(self, key, value):
		if self.word.has_key(key):
			self.wordlist[self.word[key]-1] = value
		else:
			self.wordlist.append(value)
			self.word[key] = len(self.wordlist)
		self.q.put([key, value, self.word[key]])

	def has_key(self, key):
		return self.word.has_key(key)

	def items(self):
		ret = list()
		for (k, v) in self.word.iteritems():
			ret.append((k, self.wordlist[v-1]))
		return ret
	def __del__(self):
		self.sync()

	def sync(self):
		self.saving = True
		self.q.join()
		self.p.terminate()

	def CellGetAction(self, key, wksht_id):
		# Get the list feed
		feed = self.gd_client.GetCellsFeed(key, wksht_id)
		self.GetFeed(feed)

	def GetFeed(self, feed):
		for i, entry in enumerate(feed.entry):
			if isinstance(feed, gdata.spreadsheet.SpreadsheetsCellsFeed):
				if not entry.cell.text.isdigit():
					self.word[entry.cell.text] = string.atoi(entry.cell.row)
					self.wordlist.append(0)
				else:
					self.wordlist[string.atoi(entry.cell.row)-1] = string.atoi(entry.cell.inputValue)
	def SearchForWorksheet(self, key, name):
		# Get the list of worksheets
		feed = self.gd_client.GetWorksheetsFeed(key)
		for i, entry in enumerate(feed.entry):
			if entry.title.text == name:
				curr = entry
		return curr.id.text.rsplit('/', 1)[1]
	def SearchForSpreadsheet(self, name):
		# Get the list of spreadsheets
		feed = self.gd_client.GetSpreadsheetsFeed()
		for i, entry in enumerate(feed.entry):
			if entry.title.text == name:
				curr = entry
		return curr.id.text.rsplit('/', 1)[1]


if os.access(os.getenv("HOME")+"/.ydictrc", os.F_OK):
	config = ConfigParser.ConfigParser()
	config.readfp(open(os.getenv("HOME")+"/.ydictrc"))
	dbname = config.get('ydict', 'database')
	if dbname == "google":
		username = config.get('ydict', 'username')
		password = config.get('ydict', 'password')
		spreadsheet = config.get('ydict', 'spreadsheet')
		worksheet = config.get('ydict', 'worksheet')
		db = godb(username, password, spreadsheet, worksheet)
		learn = 1
		database = 1
		
	elif dbname == "local":
		if os.access(os.getenv("HOME")+"/.ydict.db", os.F_OK):
			db = shelve.open(os.getenv("HOME")+"/.ydict.db","c")
			learn = 1
			database = 1
	try:
		voicedata = config.get('ydict', 'voicedata')
		playback = config.get('ydict', 'playback')
	except :
		pass
	
		
def cleanup():
	if database:
		db.sync()
	exit()

def importfile(file):
	fp = open(file)
	#db=shelve.open(os.getenv("HOME")+"/.ydict.db","c")
	for line in fp:
		newword=line.split(" ")[0]
		if db.has_key(newword) == 0:
			db[newword]=0
	print "File imported!"
def result(count, total):
	if total == 0:
		print ""
		exit()
	print "\nScore: ",int(count),"/",int(total),"(",count/total,")"
	exit()

def seckey(x):
        return x[1]
def speek(k):
	filename = voicedata+"/"+k[0]+"/"+k+".wav"
	if os.access(filename, os.F_OK):
		os.system(playback+" "+filename+" 2&> /dev/null &")

def answers(iq, oq):
	while(1):
		k = iq.get()
		result = dict(k, 1)
		oq.put([k, result])
def wordlearn():
	wordlist = db.items()
	wordlist.sort(key=seckey)
	size=len(wordlist)
	totalcount = 0.0
	right = 0.0
	lookup = Queue(maxsize = 5)
	answer = Queue(maxsize = 5)
	lookuper = Process( target=answers, args=(lookup, answer) )
	lookuper.daemon = True
	lookuper.start()

	if size <= 1:
		print "There must be at least two words needed in the list."
		exit()

	while(1) :
		while(not lookup.full()):
			k=wordlist[int(random.triangular(0, size-1, 0))][0]
			k=k.lower()
			lookup.put(k)
		(k, result) = answer.get()
		print result.replace(k, "####").replace(k.upper(), "####").replace(k[0].swapcase()+k[1:].lower(),"####")
		speek(k)
		word=raw_input("Input :")
		if word == k.lower():
			print "Bingo!"
			right+=1
			db[k]+=1
			if db[k] >= 100:
				db[k]=100
		else:
			db[k]-=3
			if db[k] < 0:
				db[k]=0
			print "WRONG! Correct answer is : ",k
			try:
				raw_input("Press Enter to contiune......")
			except KeyboardInterrupt:
				result(right,totalcount)
		totalcount+=1
		if totalcount % (int(size/4)+1) == 0:
			print "re-sort"
			wordlist=db.items()
			wordlist.sort(key=seckey)
def wordlist():
	#db=shelve.open(os.getenv("HOME")+"/.ydict.db","c")
	wordlist = db.items()
	wordlist.sort(key=seckey)
	for k,v in wordlist:
		print k,v

class MyHTMLParser(HTMLParser):
	redirect=0
	pron=True
	def __init__(self):
		self.show=0
		self.prefix=""
		self.postfix=org
		self.entry=1
		self.desc=0
		self.result=[]
		self.learn=learn
		self.learnword=0
		self.chinese=0

	def handle_starttag(self, tag, attrs):
		if self.redirect == 1 and tag == "strong":
			self.show=1
			self.prefix="Spell Check: ["+yellow
			self.postfix=org+"]"
		
		elif tag == "span" and len(attrs)==0:
			if self.pron == True:
				self.show=1
				self.prefix=""
		elif tag == "div" and len(attrs)==0:
			if self.pron == True:
				self.show=1
				self.prefix=""
		elif tag == "div" and len(attrs)!=0:
			if attrs[0][1]=="pronunciation" and self.pron==True:
				self.result.append(blue)
			elif attrs[0][1]=="caption":
				self.show=1
				self.prefix=red
			elif attrs[0][1]=="theme clr":
				self.show=1
				if self.chinese == 0:
					self.learnword=1
					self.prefix="["+light
					self.postfix=org+"]"
			elif attrs[0][1]=="description":
				if self.desc != 0:
					self.show=1
					self.prefix="  "+org
				self.desc+=1
		elif tag == "p" and len(attrs)!=0:
			if attrs[0][1] == "example":
				self.show=1
				self.prefix="	"+indigo
			elif attrs[0][1] == "interpret":
				self.show=1
				self.prefix="  "+org+str(self.entry)+"."
				self.entry+=1

	def handle_data(self,data):
		if self.show == 1:
			self.result.append(self.prefix+data+self.postfix+"\n")
			self.show=0
			self.prefix=""
			self.postfix=""
		if(self.learn == 1 and self.learnword == 1):
			if(db.has_key(data.lower()) == 0 and data.lower().isalpha() ):
				db[data.lower()] = 0
			self.learnword=0
			speek(data.lower())

	def handle_endtag(self, tag):
		if tag == "div":
			self.result.append(org)

def htmlspcahrs(content):
	content=content.replace("&amp;","&")
	content=content.replace("&#39;","\'")
	content=content.replace("&quot;","\"")
	content=content.replace("&gt",">")
	content=content.replace("&lt","<")
	content=content.replace("<span>","")
	content=content.replace("</span>","")
	content=content.replace("<b>",lindigo)
	content=content.replace("</b>",org+indigo)
	content=content.replace("\n","\n	"+green)
	return content


def http_postconn(word):
	yahoourl="tw.dictionary.yahoo.com"
	params = urllib.urlencode({'p': word ,'ei' : 'UTF-8'})
	return urllib.urlopen("http://%s/search" % yahoourl, params)

def dict(word,pron):
	output=""
	word=word.strip()
	if len(word) <= 0:
		return output
	r1=http_postconn(word)
	data1 = r1.read()
	p=MyHTMLParser()
	p.redirect=0
	p.chinese=0
	p.pron=pron
	try:
		#data1=data1[:16+string.index(data1,"Online Resources")]
		data1=data1[:16+string.index(data1,'<div id="adbn_BE" class="ad">')]
	except ValueError:
		return output

	
	try:
		index1=string.index(data1,"您是不是要查")
		p.redirect=1
	except ValueError:
		try:
			index1=string.index(data1,"很抱歉，字典找不到您要的資料喔！")
			return yellow+"Not Found!"+org+"\n"
		except ValueError:
			index1=string.index(data1,"字典搜尋")
	
	try:
		index3=string.index(data1,"以下為 <strong>")
		index4=string.index(data1,"</strong> 在字典中的結果")
		print yellow+"以下為 "+light+data1[index3+18:index4]+yellow+" 在字典中的結果"+org
	except ValueError:
		pass
	try:
		string.index(data1,"拼音")
		string.index(data1,"注音")
		p.chinese=1
	except ValueError:
		pass

		
	data=data1[index1:]
	p.reset()
	data=htmlspcahrs(data)
	p.feed(data)
	for s in p.result:
		output+=s
	return output


if __name__ == '__main__':
	parser = OptionParser()
	parser.add_option("-s", "--step", dest="step", help="one step mode.",default=False,action="store_true")
	parser.add_option("-p", "--pron", dest="pron", help="disable pronounce.",default=True,action="store_false")
	parser.add_option("-u", "--utf8", dest="utf8", help="force utf-8 encoding.",default=False,action="store_true")
	parser.add_option("-b", "--big5", dest="big5", help="force big5 encoding.",default=False,action="store_true")
	parser.add_option("-w", "--word", dest="oneword", type="string" , help="only one word.",action="store")
	parser.add_option("-v", "--version", dest="version", help="show version.",default=False,action="store_true")
	parser.add_option("-d", "--database", dest="database", help="initial database.",default=False,action="store_true")
	parser.add_option("-l", "--learn", dest="learnmode", help="start learning mode.",default=False,action="store_true")
	parser.add_option("-a", "--list", dest="listall", help="list all word in list.",default=False,action="store_true")
	parser.add_option("-i", "--import", dest="importfile", type="string", help="import a word list",default=False,action="store")

	(options, args) = parser.parse_args()
	m_pron=options.pron
	(lang , enc)=locale.getdefaultlocale()

	if options.importfile:
		importfile(options.importfile)
		cleanup()
		
	if options.version == True:
		print version
		cleanup()
	if options.utf8 == True:
		enc="utf8"
	elif options.big5 == True:
		enc="big5"

	if options.utf8 == options.big5 ==True:
		print "Can not select utf-8 and big5 at the same time"
		cleanup()
	if enc == 'big5':
		m_pron=False
	
	if options.oneword:
		result=dict(options.oneword,m_pron)
		result=unicode(result,'utf8')
		result=result.encode(enc)
		print result
		cleanup()
	if options.learnmode:
		try:
			wordlearn()
		except KeyboardInterrupt:
			print ""
			cleanup()
		except EOFError:
			print ""
			cleanup()
		cleanup()
	elif options.listall:
		wordlist()
		cleanup()
	if options.database == True:
	        db=shelve.open(os.getenv("HOME")+"/.ydict.db","c")
	        db.close()
	        exit()


	while(1):
		try:
			word=raw_input("<PyDict> ")
		except KeyboardInterrupt:
			print ""
			cleanup()
		except EOFError:
			print ""
			cleanup()

		result=dict(word,m_pron)
		result=unicode(result,'utf8')
		result=result.encode(enc)
		print result

		if options.step == True:
			cleanup()

